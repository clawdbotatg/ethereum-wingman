# ERC-4626: Tokenized Vault Standard

## Overview

ERC-4626 is the standard for tokenized vaults - contracts that hold assets and issue shares representing deposits. It standardizes deposit/withdrawal mechanics, share accounting, and yield distribution, making it the foundation for lending pools, yield aggregators, and liquid staking.

## Core Concept

```
┌─────────────────────────────────────────────────────────────────┐
│ VAULT MECHANICS                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│ User deposits 100 USDC                                          │
│        ↓                                                        │
│ Vault issues 100 shares (if 1:1 at start)                       │
│        ↓                                                        │
│ Vault earns yield → holds 110 USDC                              │
│        ↓                                                        │
│ User's 100 shares now worth 110 USDC                            │
│        ↓                                                        │
│ User redeems 100 shares → receives 110 USDC                     │
│                                                                 │
│ Share price = Total Assets / Total Shares                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

## Interface

```solidity
interface IERC4626 is IERC20 {
    // Events
    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);
    event Withdraw(address indexed sender, address indexed receiver, address indexed owner, uint256 assets, uint256 shares);
    
    // Asset info
    function asset() external view returns (address);
    function totalAssets() external view returns (uint256);
    
    // Conversion functions
    function convertToShares(uint256 assets) external view returns (uint256);
    function convertToAssets(uint256 shares) external view returns (uint256);
    
    // Max functions
    function maxDeposit(address receiver) external view returns (uint256);
    function maxMint(address receiver) external view returns (uint256);
    function maxWithdraw(address owner) external view returns (uint256);
    function maxRedeem(address owner) external view returns (uint256);
    
    // Preview functions
    function previewDeposit(uint256 assets) external view returns (uint256);
    function previewMint(uint256 shares) external view returns (uint256);
    function previewWithdraw(uint256 assets) external view returns (uint256);
    function previewRedeem(uint256 shares) external view returns (uint256);
    
    // Deposit/Withdraw
    function deposit(uint256 assets, address receiver) external returns (uint256 shares);
    function mint(uint256 shares, address receiver) external returns (uint256 assets);
    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);
    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);
}
```

## Key Functions Explained

### Deposit vs Mint
```solidity
// deposit: Specify assets, get calculated shares
function deposit(uint256 assets, address receiver) external returns (uint256 shares) {
    shares = previewDeposit(assets);
    // Transfer assets from caller
    asset.transferFrom(msg.sender, address(this), assets);
    // Mint shares to receiver
    _mint(receiver, shares);
    emit Deposit(msg.sender, receiver, assets, shares);
}

// mint: Specify shares, pay calculated assets
function mint(uint256 shares, address receiver) external returns (uint256 assets) {
    assets = previewMint(shares);
    asset.transferFrom(msg.sender, address(this), assets);
    _mint(receiver, shares);
    emit Deposit(msg.sender, receiver, assets, shares);
}
```

### Withdraw vs Redeem
```solidity
// withdraw: Specify assets to receive, burn calculated shares
function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares) {
    shares = previewWithdraw(assets);
    if (msg.sender != owner) {
        _spendAllowance(owner, msg.sender, shares);
    }
    _burn(owner, shares);
    asset.transfer(receiver, assets);
    emit Withdraw(msg.sender, receiver, owner, assets, shares);
}

// redeem: Specify shares to burn, receive calculated assets
function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets) {
    assets = previewRedeem(shares);
    if (msg.sender != owner) {
        _spendAllowance(owner, msg.sender, shares);
    }
    _burn(owner, shares);
    asset.transfer(receiver, assets);
    emit Withdraw(msg.sender, receiver, owner, assets, shares);
}
```

## Implementation

### Basic Vault
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol";

contract SimpleVault is ERC4626 {
    constructor(IERC20 _asset) 
        ERC4626(_asset)
        ERC20("Vault Shares", "vSHARE")
    {}
    
    // Override totalAssets to include yield
    function totalAssets() public view override returns (uint256) {
        return asset.balanceOf(address(this));
    }
}
```

### Yield-Generating Vault
```solidity
contract YieldVault is ERC4626 {
    uint256 public constant YIELD_BPS = 500; // 5% APY
    uint256 public lastHarvestTime;
    
    constructor(IERC20 _asset) ERC4626(_asset) ERC20("Yield Vault", "yVAULT") {
        lastHarvestTime = block.timestamp;
    }
    
    function totalAssets() public view override returns (uint256) {
        uint256 baseAssets = asset.balanceOf(address(this));
        uint256 timeElapsed = block.timestamp - lastHarvestTime;
        uint256 yield = (baseAssets * YIELD_BPS * timeElapsed) / (365 days * 10000);
        return baseAssets + yield;
    }
    
    function harvest() external {
        // Claim actual yield from underlying protocol
        // Update lastHarvestTime
    }
}
```

## CRITICAL: Inflation Attack

### The Attack

```
First depositor vulnerability:

1. Attacker deposits 1 wei → gets 1 share
2. Attacker donates 10000 tokens to vault (not via deposit)
3. Share price = 10001 / 1 = 10001 tokens per share
4. Victim deposits 9999 tokens
5. Victim gets floor(9999 / 10001) = 0 shares!
6. Attacker redeems 1 share → gets all 20000 tokens
```

### Mitigations

```solidity
// Solution 1: Virtual shares/assets offset
contract SafeVault is ERC4626 {
    uint256 internal constant OFFSET = 1e3;
    
    function _convertToShares(uint256 assets, Math.Rounding rounding) 
        internal view override returns (uint256) 
    {
        return assets.mulDiv(totalSupply() + OFFSET, totalAssets() + 1, rounding);
    }
    
    function _convertToAssets(uint256 shares, Math.Rounding rounding)
        internal view override returns (uint256)
    {
        return shares.mulDiv(totalAssets() + 1, totalSupply() + OFFSET, rounding);
    }
}

// Solution 2: Dead shares (OpenZeppelin default in v5)
// Mint some shares to zero address at initialization
constructor(IERC20 _asset) ERC4626(_asset) ERC20("Safe Vault", "sVAULT") {
    _mint(address(0), 1000); // Dead shares
}

// Solution 3: Minimum deposit
function deposit(uint256 assets, address receiver) public override returns (uint256) {
    require(assets >= MIN_DEPOSIT, "Below minimum");
    return super.deposit(assets, receiver);
}
```

## Integration Patterns

### Depositing into Vault
```solidity
contract VaultUser {
    IERC4626 public vault;
    IERC20 public asset;
    
    function depositToVault(uint256 amount) external {
        // 1. Transfer asset from user
        asset.transferFrom(msg.sender, address(this), amount);
        
        // 2. Approve vault
        asset.approve(address(vault), amount);
        
        // 3. Deposit and get shares
        uint256 shares = vault.deposit(amount, msg.sender);
    }
    
    function withdrawFromVault(uint256 shares) external {
        // Redeem shares for underlying
        uint256 assets = vault.redeem(shares, msg.sender, msg.sender);
    }
}
```

### Yield Aggregator Pattern
```solidity
contract YieldAggregator is ERC4626 {
    IERC4626[] public strategies;
    
    function totalAssets() public view override returns (uint256 total) {
        total = asset.balanceOf(address(this));
        for (uint256 i = 0; i < strategies.length; i++) {
            total += strategies[i].convertToAssets(strategies[i].balanceOf(address(this)));
        }
    }
    
    function rebalance() external {
        // Move assets between strategies for optimal yield
    }
}
```

## Security Checklist

- [ ] Protect against inflation/donation attack
- [ ] Handle fee-on-transfer tokens properly
- [ ] Round in favor of vault (down on deposit, up on withdraw)
- [ ] Implement proper max* functions for limits
- [ ] Consider reentrancy in deposit/withdraw
- [ ] Test edge cases (first deposit, empty vault)
- [ ] Validate totalAssets() includes all yield sources

## Common Gotchas

1. **Rounding Direction**: Always round against the user
   - Deposit: round shares DOWN
   - Withdraw: round assets DOWN
   
2. **Max Functions**: Must reflect actual limits
   - Consider allowance, vault capacity, liquidity

3. **Preview vs Actual**: Preview should match actual (or be conservative)

4. **Share Price Manipulation**: Large deposits can manipulate price

## Use Cases

- Lending pools (Aave aTokens, Compound cTokens)
- Yield aggregators (Yearn, Beefy)
- Liquid staking (Lido wstETH, Rocket Pool rETH)
- Option vaults (Ribbon, Dopex)
- Insurance pools
