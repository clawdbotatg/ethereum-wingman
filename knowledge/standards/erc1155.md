# ERC-1155: Multi-Token Standard

## Overview

ERC-1155 is a multi-token standard that can represent both fungible (like ERC-20) and non-fungible tokens (like ERC-721) in a single contract. It's highly gas-efficient for batch operations and is commonly used in gaming, where you need many different item types.

## Key Advantages

```
┌─────────────────────────────────────────────────────────────────┐
│ ERC-1155 vs ERC-20 + ERC-721                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│ Single Contract: All token types in one deployment              │
│ Batch Transfers: Send multiple items in one transaction         │
│ Gas Efficient: ~50% cheaper for batch operations                │
│ Flexible: Same contract for fungible AND non-fungible           │
│                                                                 │
│ Example: Gaming inventory                                       │
│ ID 1: Gold coins (fungible, supply: 1,000,000)                  │
│ ID 2: Silver coins (fungible, supply: 500,000)                  │
│ ID 3: Legendary Sword #1 (NFT, supply: 1)                       │
│ ID 4: Common Potion (semi-fungible, supply: 100)                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

## Interface

```solidity
interface IERC1155 {
    // Events
    event TransferSingle(
        address indexed operator,
        address indexed from,
        address indexed to,
        uint256 id,
        uint256 value
    );
    
    event TransferBatch(
        address indexed operator,
        address indexed from,
        address indexed to,
        uint256[] ids,
        uint256[] values
    );
    
    event ApprovalForAll(address indexed account, address indexed operator, bool approved);
    event URI(string value, uint256 indexed id);
    
    // Balance queries
    function balanceOf(address account, uint256 id) external view returns (uint256);
    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) 
        external view returns (uint256[] memory);
    
    // Approvals (all-or-nothing, no single-token approval)
    function setApprovalForAll(address operator, bool approved) external;
    function isApprovedForAll(address account, address operator) external view returns (bool);
    
    // Transfers
    function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes calldata data
    ) external;
    
    function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] calldata ids,
        uint256[] calldata amounts,
        bytes calldata data
    ) external;
}
```

## Metadata Extension

```solidity
interface IERC1155MetadataURI {
    function uri(uint256 id) external view returns (string memory);
}

// URI can include {id} placeholder that clients replace
// e.g., "https://api.game.com/items/{id}.json"
// Client replaces {id} with token ID (hex, padded to 64 chars)
```

## Implementation

### Basic ERC-1155
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "@openzeppelin/contracts/token/ERC1155/ERC1155.sol";

contract GameItems is ERC1155 {
    uint256 public constant GOLD = 0;
    uint256 public constant SILVER = 1;
    uint256 public constant SWORD = 2;
    uint256 public constant SHIELD = 3;
    
    constructor() ERC1155("https://game.example/api/item/{id}.json") {
        // Mint fungible tokens
        _mint(msg.sender, GOLD, 10**18, "");
        _mint(msg.sender, SILVER, 10**27, "");
        
        // Mint NFTs (supply = 1)
        _mint(msg.sender, SWORD, 1, "");
        _mint(msg.sender, SHIELD, 1, "");
    }
}
```

### Mintable with Supply Tracking
```solidity
contract MintableERC1155 is ERC1155 {
    mapping(uint256 => uint256) public totalSupply;
    mapping(uint256 => uint256) public maxSupply;
    
    function mint(address to, uint256 id, uint256 amount) external {
        require(totalSupply[id] + amount <= maxSupply[id], "Exceeds max supply");
        totalSupply[id] += amount;
        _mint(to, id, amount, "");
    }
    
    function mintBatch(address to, uint256[] memory ids, uint256[] memory amounts) external {
        for (uint256 i = 0; i < ids.length; i++) {
            require(totalSupply[ids[i]] + amounts[i] <= maxSupply[ids[i]], "Exceeds max");
            totalSupply[ids[i]] += amounts[i];
        }
        _mintBatch(to, ids, amounts, "");
    }
}
```

## Receiver Interface

```solidity
interface IERC1155Receiver {
    function onERC1155Received(
        address operator,
        address from,
        uint256 id,
        uint256 value,
        bytes calldata data
    ) external returns (bytes4);
    
    function onERC1155BatchReceived(
        address operator,
        address from,
        uint256[] calldata ids,
        uint256[] calldata values,
        bytes calldata data
    ) external returns (bytes4);
}

// Contracts receiving ERC1155 must implement this
contract ERC1155Holder is IERC1155Receiver {
    function onERC1155Received(
        address, address, uint256, uint256, bytes calldata
    ) external pure returns (bytes4) {
        return IERC1155Receiver.onERC1155Received.selector;
    }
    
    function onERC1155BatchReceived(
        address, address, uint256[] calldata, uint256[] calldata, bytes calldata
    ) external pure returns (bytes4) {
        return IERC1155Receiver.onERC1155BatchReceived.selector;
    }
}
```

## Common Patterns

### Fungible vs Non-Fungible Detection
```solidity
contract MultiToken is ERC1155 {
    mapping(uint256 => bool) public isNFT;
    mapping(uint256 => uint256) private _totalSupply;
    
    function mintFungible(address to, uint256 id, uint256 amount) external {
        require(!isNFT[id], "ID is NFT");
        _totalSupply[id] += amount;
        _mint(to, id, amount, "");
    }
    
    function mintNFT(address to, uint256 id) external {
        require(_totalSupply[id] == 0, "Already minted");
        isNFT[id] = true;
        _totalSupply[id] = 1;
        _mint(to, id, 1, "");
    }
}
```

### Token Type Ranges
```solidity
contract TypedTokens is ERC1155 {
    // Reserve ID ranges for different types
    // 0-999: Fungible currency tokens
    // 1000-9999: Consumable items (semi-fungible)
    // 10000+: Unique NFTs
    
    function isFungible(uint256 id) public pure returns (bool) {
        return id < 1000;
    }
    
    function isConsumable(uint256 id) public pure returns (bool) {
        return id >= 1000 && id < 10000;
    }
    
    function isNFT(uint256 id) public pure returns (bool) {
        return id >= 10000;
    }
}
```

### Batch Operations
```solidity
contract BatchOperations is ERC1155 {
    // Efficient airdrop
    function airdrop(
        address[] calldata recipients,
        uint256 id,
        uint256 amount
    ) external {
        for (uint256 i = 0; i < recipients.length; i++) {
            _mint(recipients[i], id, amount, "");
        }
    }
    
    // Bundle transfer (send multiple items to one recipient)
    function sendBundle(
        address to,
        uint256[] calldata ids,
        uint256[] calldata amounts
    ) external {
        safeBatchTransferFrom(msg.sender, to, ids, amounts, "");
    }
}
```

## Security Considerations

### Reentrancy in Receivers
```solidity
// Both onERC1155Received and onERC1155BatchReceived can be exploited
// Always use checks-effects-interactions

// BAD
function withdraw(uint256 id, uint256 amount) external {
    safeTransferFrom(address(this), msg.sender, id, amount, "");
    balances[msg.sender] -= amount; // Can be reentered!
}

// GOOD
function withdraw(uint256 id, uint256 amount) external {
    balances[msg.sender] -= amount;
    safeTransferFrom(address(this), msg.sender, id, amount, "");
}
```

### Supply Manipulation
```solidity
// Track supply to prevent over-minting
// Especially important for "limited edition" items

mapping(uint256 => uint256) public maxSupply;
mapping(uint256 => uint256) public currentSupply;

function mint(uint256 id, uint256 amount) external {
    require(currentSupply[id] + amount <= maxSupply[id], "Exceeds max");
    currentSupply[id] += amount;
    _mint(msg.sender, id, amount, "");
}
```

## Use Cases

| Use Case | Example |
|----------|---------|
| Gaming | Inventory items, currencies, achievements |
| Ticketing | Event tickets with seat numbers |
| Art | Editions of the same artwork |
| Music | Album copies with unique serial numbers |
| Loyalty | Points and reward tiers |

## Comparison

| Feature | ERC-20 | ERC-721 | ERC-1155 |
|---------|--------|---------|----------|
| Fungible | Yes | No | Yes |
| Non-Fungible | No | Yes | Yes |
| Multiple Types | No | No | Yes |
| Batch Transfer | No | No | Yes |
| Per-Token Approval | Yes | Yes | No |

## Security Checklist

- [ ] Implement IERC1155Receiver for receiving contracts
- [ ] Track supply for limited items
- [ ] Use CEI pattern in withdrawals
- [ ] Validate array lengths match in batch operations
- [ ] Consider reentrancy in receiver callbacks
- [ ] Test both single and batch transfers
