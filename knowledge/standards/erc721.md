# ERC-721: Non-Fungible Token Standard

## Overview

ERC-721 is the standard for non-fungible tokens (NFTs) on Ethereum. Each token is unique with its own ID, making them suitable for digital art, collectibles, gaming items, real estate, and any unique digital or physical asset.

## Interface

```solidity
interface IERC721 {
    // Events
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
    
    // Balance and ownership
    function balanceOf(address owner) external view returns (uint256);
    function ownerOf(uint256 tokenId) external view returns (address);
    
    // Safe transfers (checks if receiver can handle NFTs)
    function safeTransferFrom(address from, address to, uint256 tokenId) external;
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;
    
    // Unsafe transfer (use with caution)
    function transferFrom(address from, address to, uint256 tokenId) external;
    
    // Approval for single token
    function approve(address to, uint256 tokenId) external;
    function getApproved(uint256 tokenId) external view returns (address);
    
    // Approval for all tokens
    function setApprovalForAll(address operator, bool approved) external;
    function isApprovedForAll(address owner, address operator) external view returns (bool);
}
```

## Metadata Extension

```solidity
interface IERC721Metadata {
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function tokenURI(uint256 tokenId) external view returns (string memory);
}

// tokenURI returns a URL to JSON metadata:
{
    "name": "NFT Name",
    "description": "NFT Description",
    "image": "ipfs://...",
    "attributes": [
        {"trait_type": "Background", "value": "Blue"},
        {"trait_type": "Rarity", "value": "Legendary"}
    ]
}
```

## Key Concepts

### Safe vs Unsafe Transfers

```solidity
// safeTransferFrom checks if receiver can handle NFTs
// If receiver is a contract, it must implement IERC721Receiver

interface IERC721Receiver {
    function onERC721Received(
        address operator,
        address from,
        uint256 tokenId,
        bytes calldata data
    ) external returns (bytes4);
    
    // Must return: bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))
}

// Contract that can receive NFTs
contract NFTReceiver is IERC721Receiver {
    function onERC721Received(
        address, address, uint256, bytes calldata
    ) external pure returns (bytes4) {
        return IERC721Receiver.onERC721Received.selector;
    }
}

// transferFrom does NOT check - NFT can be lost if sent to incompatible contract!
```

### Approvals

```solidity
// Single token approval
nft.approve(spenderAddress, tokenId);

// Operator approval (all tokens)
nft.setApprovalForAll(marketplaceAddress, true);

// Check who can transfer
address approved = nft.getApproved(tokenId);      // Single token
bool isOperator = nft.isApprovedForAll(owner, operator);  // All tokens
```

## Implementation

### Basic NFT
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

contract MyNFT is ERC721 {
    using Counters for Counters.Counter;
    Counters.Counter private _tokenIds;
    
    constructor() ERC721("MyNFT", "MNFT") {}
    
    function mint(address to) external returns (uint256) {
        _tokenIds.increment();
        uint256 newId = _tokenIds.current();
        _safeMint(to, newId);
        return newId;
    }
}
```

### NFT with Metadata
```solidity
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";

contract NFTWithMetadata is ERC721URIStorage {
    using Counters for Counters.Counter;
    Counters.Counter private _tokenIds;
    
    constructor() ERC721("Art", "ART") {}
    
    function mint(address to, string memory metadataURI) external returns (uint256) {
        _tokenIds.increment();
        uint256 newId = _tokenIds.current();
        _safeMint(to, newId);
        _setTokenURI(newId, metadataURI);
        return newId;
    }
}
```

### Enumerable NFT
```solidity
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";

contract EnumerableNFT is ERC721Enumerable {
    // Adds ability to iterate all tokens and tokens by owner
    // More gas expensive for transfers!
    
    // List all tokens owned by address:
    function tokensOfOwner(address owner) external view returns (uint256[] memory) {
        uint256 count = balanceOf(owner);
        uint256[] memory tokens = new uint256[](count);
        for (uint256 i = 0; i < count; i++) {
            tokens[i] = tokenOfOwnerByIndex(owner, i);
        }
        return tokens;
    }
}
```

## Marketplace Patterns

### Listing for Sale
```solidity
contract NFTMarketplace {
    struct Listing {
        address seller;
        uint256 price;
    }
    
    mapping(address => mapping(uint256 => Listing)) public listings;
    
    function list(address nft, uint256 tokenId, uint256 price) external {
        require(IERC721(nft).ownerOf(tokenId) == msg.sender, "Not owner");
        require(IERC721(nft).isApprovedForAll(msg.sender, address(this)), "Not approved");
        
        listings[nft][tokenId] = Listing(msg.sender, price);
    }
    
    function buy(address nft, uint256 tokenId) external payable {
        Listing memory listing = listings[nft][tokenId];
        require(listing.price > 0, "Not listed");
        require(msg.value >= listing.price, "Insufficient payment");
        
        delete listings[nft][tokenId];
        
        IERC721(nft).safeTransferFrom(listing.seller, msg.sender, tokenId);
        payable(listing.seller).transfer(listing.price);
    }
}
```

### Royalties (EIP-2981)
```solidity
import "@openzeppelin/contracts/interfaces/IERC2981.sol";

contract NFTWithRoyalties is ERC721, IERC2981 {
    address public royaltyRecipient;
    uint96 public royaltyBps = 500; // 5%
    
    function royaltyInfo(uint256, uint256 salePrice) external view returns (address, uint256) {
        uint256 royaltyAmount = (salePrice * royaltyBps) / 10000;
        return (royaltyRecipient, royaltyAmount);
    }
    
    function supportsInterface(bytes4 interfaceId) public view override(ERC721, IERC165) returns (bool) {
        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);
    }
}
```

## Security Considerations

### Reentrancy in onERC721Received
```solidity
// BAD: State change after safeTransfer
function withdraw(uint256 tokenId) external {
    _safeTransfer(address(this), msg.sender, tokenId, "");
    userTokenCount[msg.sender]--; // Can be reentered!
}

// GOOD: CEI pattern
function withdraw(uint256 tokenId) external {
    userTokenCount[msg.sender]--;
    _safeTransfer(address(this), msg.sender, tokenId, "");
}
```

### Approval Phishing
```solidity
// Users tricked into calling setApprovalForAll to malicious address
// Attacker can steal ALL their NFTs

// Mitigation: 
// - Always verify contract addresses
// - Use approval for single tokens when possible
// - Revoke unused approvals
```

### Metadata Poisoning
```solidity
// If tokenURI points to changeable content, metadata can be swapped
// IPFS is content-addressed but can be unpinned

// Best practices:
// - Use on-chain SVGs for important traits
// - Pin IPFS content on multiple services
// - Use Arweave for permanence
```

## Common Extensions

| Extension | Purpose |
|-----------|---------|
| ERC721URIStorage | Individual token metadata URIs |
| ERC721Enumerable | Iterate all tokens |
| ERC721Burnable | Allow token burning |
| ERC721Pausable | Emergency pause |
| ERC721Royalty | On-chain royalty info |

## Security Checklist

- [ ] Use _safeMint instead of _mint
- [ ] Implement onERC721Received for receiving contracts
- [ ] Follow CEI pattern in transfers
- [ ] Validate tokenId exists before operations
- [ ] Consider metadata immutability
- [ ] Test approval/transfer edge cases
